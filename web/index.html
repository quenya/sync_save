<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sync_save</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&family=Inter:wght@400;500;600&display=swap");

      :root {
        --bg: linear-gradient(160deg, #0f172a 0%, #0b2a4a 52%, #172554 100%);
        --panel: rgba(255, 255, 255, 0.94);
        --text: #0f172a;
        --sub: #475569;
        --line: rgba(148, 163, 184, 0.32);
        --accent: #0ea5e9;
        --accent-strong: #0284c7;
        --danger: #e11d48;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        min-height: 100vh;
        color: var(--text);
        font-family: "Inter", "Apple SD Gothic Neo", sans-serif;
        background: var(--bg);
      }

      .shell {
        max-width: 1100px;
        margin: 0 auto;
        padding: 24px;
        display: grid;
        gap: 16px;
      }

      h1,
      h2,
      h3 {
        margin: 0;
        font-family: "Space Grotesk", sans-serif;
        letter-spacing: 0.2px;
      }

      h1 {
        font-size: 36px;
      }

      h2 {
        font-size: 22px;
      }

      .card {
        background: var(--panel);
        border-radius: 14px;
        border: 1px solid var(--line);
        padding: 16px;
        backdrop-filter: blur(4px);
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .stack {
        display: grid;
        gap: 10px;
      }

      .input {
        border: 1px solid #cbd5e1;
        border-radius: 10px;
        padding: 10px 12px;
        background: #fff;
        width: min(360px, 100%);
      }

      .btn {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #ffffff;
        color: #0f172a;
        padding: 10px 14px;
        font-weight: 600;
        cursor: pointer;
      }

      .btn.primary {
        background: var(--accent);
        color: #fff;
        border-color: var(--accent);
      }

      .btn.primary:hover {
        background: var(--accent-strong);
      }

      .btn.danger {
        background: #fee2e2;
        color: #7f1d1d;
        border-color: #fecdd3;
      }

      .muted {
        color: var(--sub);
        font-size: 13px;
      }

      .split {
        display: grid;
        gap: 16px;
        grid-template-columns: 1fr 1fr;
      }

      .panel-title {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .status {
        padding: 9px 11px;
        border-radius: 10px;
        background: #e2e8f0;
        border: 1px solid #cbd5e1;
      }

      .status.ok { background: #dcfce7; border-color: #86efac; }
      .status.warn { background: #fef08a; border-color: #fde047; }
      .status.err { background: #ffe4e6; border-color: #fda4af; }

      ul.clean {
        margin: 0;
        padding: 0;
        list-style: none;
        display: grid;
        gap: 6px;
      }

      .chip {
        padding: 6px 10px;
        border: 1px solid #bae6fd;
        border-radius: 999px;
        font-size: 11px;
        color: #0c4a6e;
        width: fit-content;
      }

      .game-item, .rev-item {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        cursor: pointer;
      }

      .game-item.active { border-color: #0ea5e9; background: #f0f9ff; }

      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 12px;
      }

      @media (max-width: 860px) {
        .split {
          grid-template-columns: 1fr;
        }

        .shell {
          padding: 12px;
        }

        h1 {
          font-size: 28px;
        }
      }
    </style>
  </head>
  <body>
    <main class="shell">
      <header class="card">
        <h1>sync_save</h1>
        <p class="muted">OAuth(모의) 로그인 + 계정별 게임 저장 동기화 대시보드</p>
      </header>

      <section class="card">
        <div class="panel-title">
          <h2>계정</h2>
          <span class="status" id="authStatus">로그아웃 상태</span>
        </div>
        <div class="row" style="margin-top: 10px; align-items: flex-start;">
          <div class="stack">
            <label>OAuth Provider</label>
            <select id="provider" class="input"></select>
            <input id="oauthId" class="input" placeholder="providerUserId" />
            <input id="oauthEmail" class="input" type="email" placeholder="user@example.com" />
            <input id="oauthName" class="input" placeholder="Player One" />
            <div class="row">
              <button class="btn primary" id="oauthLoginBtn">로그인</button>
              <button class="btn danger" id="logoutBtn">로그아웃</button>
            </div>
          </div>
          <div class="stack">
            <label>세션</label>
            <input id="apiBase" class="input" value="http://localhost:3000" />
            <p class="muted">access/refresh 토큰이 브라우저 LocalStorage에 저장됩니다.</p>
            <button class="btn" id="refreshBtn">토큰 갱신</button>
          </div>
        </div>
      </section>

      <section class="card split">
        <div>
          <div class="panel-title">
            <h2>게임 등록/목록</h2>
            <span class="chip">User scoped</span>
          </div>
          <div class="stack" style="margin-top: 10px;">
            <input id="gameName" class="input" placeholder="게임명" />
            <input id="savePath" class="input" placeholder="예: /saves/stardew" />
            <button class="btn primary" id="createGameBtn">게임 등록</button>
            <div id="gameMessage" class="muted"></div>
            <ul id="gameList" class="clean"></ul>
          </div>
        </div>

        <div>
          <div class="panel-title">
            <h2>선택 게임</h2>
            <span class="status warn" id="selectedLabel">게임 선택 필요</span>
          </div>
          <div class="stack" style="margin-top: 10px;">
            <div id="selectedSummary" class="muted">게임을 클릭하면 상세 정보를 표시합니다.</div>
            <h3>리비전 업로드</h3>
            <input id="checksum" class="input" placeholder="checksum" />
            <input id="sizeBytes" class="input" placeholder="sizeBytes" />
            <input id="clientUpdatedAt" class="input" placeholder="clientUpdatedAt(선택, ISO)" />
            <input id="note" class="input" placeholder="note" />
            <div class="row">
              <button class="btn primary" id="uploadRevisionBtn">저장 업로드</button>
              <button class="btn" id="forceUploadBtn">강제 업로드(시간 갱신)</button>
            </div>
            <div id="uploadMessage" class="muted"></div>

            <h3>리비전 목록</h3>
            <button class="btn" id="refreshRevisionsBtn">리비전 새로고침</button>
            <ul id="revisionList" class="clean"></ul>
            <p id="downloadLog" class="muted"></p>
          </div>
        </div>
      </section>
    </main>

    <script>
      const KEYS = {
        accessToken: "sync_save_access_token",
        refreshToken: "sync_save_refresh_token",
      };

      const state = {
        accessToken: null,
        refreshToken: null,
        games: [],
        selectedGame: null,
        revisions: [],
      };

      const el = {};
      for (const id of [
        "authStatus", "provider", "oauthId", "oauthEmail", "oauthName", "oauthLoginBtn",
        "logoutBtn", "apiBase", "refreshBtn", "gameName", "savePath", "createGameBtn",
        "gameMessage", "gameList", "selectedLabel", "selectedSummary", "checksum", "sizeBytes",
        "clientUpdatedAt", "note", "uploadRevisionBtn", "forceUploadBtn", "uploadMessage",
        "refreshRevisionsBtn", "revisionList", "downloadLog",
      ]) {
        el[id] = document.getElementById(id);
      }

      const apiBase = () => {
        const raw = (el.apiBase.value || "").trim();
        return raw || "http://localhost:3000";
      };

      const apiHeaders = (withAuth = false) => {
        const headers = { "content-type": "application/json" };
        if (withAuth && state.accessToken) {
          headers.authorization = `Bearer ${state.accessToken}`;
        }
        return headers;
      };

      function setAuthState() {
        el.authStatus.textContent = state.accessToken ? "로그인됨" : "로그아웃 상태";
        el.authStatus.className = `status ${state.accessToken ? "ok" : "warn"}`;
        el.logoutBtn.disabled = !state.accessToken;
        el.refreshBtn.disabled = !state.refreshToken;
      }

      function setMessage(target, msg, isError = false) {
        target.textContent = msg || "";
        target.className = isError ? "muted" : "muted";
      }

      async function request(path, options = {}, retry = true) {
        const res = await fetch(`${apiBase()}${path}`, {
          ...options,
          headers: apiHeaders(options.withAuth),
        });

        if (res.status === 401 && retry && state.refreshToken) {
          const refreshed = await fetch(`${apiBase()}/auth/refresh`, {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({ refreshToken: state.refreshToken }),
          });

          if (refreshed.ok) {
            const data = await refreshed.json();
            state.accessToken = data.accessToken;
            state.refreshToken = data.refreshToken;
            localStorage.setItem(KEYS.accessToken, state.accessToken);
            localStorage.setItem(KEYS.refreshToken, state.refreshToken);
            setAuthState();
            return request(path, options, false);
          }
          state.accessToken = null;
          state.refreshToken = null;
          localStorage.removeItem(KEYS.accessToken);
          localStorage.removeItem(KEYS.refreshToken);
          setAuthState();
        }

        return res;
      }

      function readResponseSafe(res) {
        return res.text().then((text) => {
          if (!text) {
            return {};
          }
          try {
            return JSON.parse(text);
          } catch (_error) {
            return { raw: text };
          }
        });
      }

      async function loadProviders() {
        const res = await request("/auth/providers");
        const data = await readResponseSafe(res);
        el.provider.innerHTML = "";
        (data.providers || []).forEach((provider) => {
          const option = document.createElement("option");
          option.value = provider;
          option.textContent = provider;
          el.provider.appendChild(option);
        });
      }

      async function loadGames() {
        if (!state.accessToken) {
          el.gameList.innerHTML = "";
          return;
        }
        const res = await request("/games", { withAuth: true });
        const data = await readResponseSafe(res);
        if (!res.ok) {
          setMessage(el.gameMessage, data.error || "게임 목록 조회 실패", true);
          return;
        }

        state.games = data.games || [];
        renderGames();
      }

      function renderGames() {
        el.gameList.innerHTML = "";
        state.games.forEach((game) => {
          const li = document.createElement("li");
          li.className = "game-item";
          if (state.selectedGame && state.selectedGame.id === game.id) {
            li.classList.add("active");
          }
          li.innerHTML = `<b>${game.name}</b><div class=\"mono muted\">id: ${game.id} · path: ${game.savePath}</div>`;
          li.onclick = () => selectGame(game);
          el.gameList.appendChild(li);
        });
      }

      function selectGame(game) {
        state.selectedGame = game;
        el.selectedLabel.textContent = `선택됨: ${game.name}`;
        el.selectedLabel.className = "status ok";
        el.selectedSummary.textContent = `gameId=${game.id}, savePath=${game.savePath}`;
        renderGames();
        loadRevisions();
      }

      async function loadRevisions() {
        if (!state.selectedGame || !state.accessToken) {
          el.revisionList.innerHTML = "";
          return;
        }

        const res = await request(`/games/${state.selectedGame.id}/revisions`, { withAuth: true });
        const data = await readResponseSafe(res);
        if (!res.ok) {
          setMessage(el.uploadMessage, data.error || "리비전 조회 실패", true);
          return;
        }

        state.revisions = data.revisions || [];
        renderRevisions();
      }

      function renderRevisions() {
        el.revisionList.innerHTML = "";
        state.revisions.forEach((revision) => {
          const li = document.createElement("li");
          li.className = "rev-item";
          li.innerHTML = `
            <div><strong>rev #${revision.id}</strong> · ${revision.createdAt}</div>
            <div class=\"mono muted\">size ${revision.sizeBytes} · checksum ${revision.checksum}</div>
          `;

          const action = document.createElement("button");
          action.className = "btn";
          action.textContent = "다운로드 모의";
          action.onclick = () => downloadRevision(revision.id);

          li.appendChild(action);
          el.revisionList.appendChild(li);
        });

        if (!state.revisions.length) {
          const none = document.createElement("li");
          none.textContent = "리비전이 없습니다.";
          none.className = "muted";
          el.revisionList.appendChild(none);
        }
      }

      async function downloadRevision(revisionId) {
        const res = await request(
          `/games/${state.selectedGame.id}/revisions/${revisionId}/download`,
          { method: "POST", withAuth: true }
        );
        const data = await readResponseSafe(res);
        if (!res.ok) {
          el.downloadLog.textContent = `다운로드 실패: ${data.error || "unknown"}`;
          return;
        }
        el.downloadLog.textContent = `다운로드 준비됨: ${data.download.artifactPath}`;
      }

      async function login() {
        const provider = el.provider.value;
        const providerUserId = el.oauthId.value.trim() || `${provider}-user-${Date.now()}`;
        const email = el.oauthEmail.value.trim() || `${provider}-user@local.test`;
        const name = el.oauthName.value.trim() || "Player One";

        const res = await request(`/auth/oauth/${provider}`, {
          method: "POST",
          headers: apiHeaders(),
          body: JSON.stringify({ providerUserId, email, name }),
        });
        const data = await readResponseSafe(res);

        if (!res.ok) {
          setMessage(el.authStatus, data.error || "로그인 실패", true);
          return;
        }

        state.accessToken = data.accessToken;
        state.refreshToken = data.refreshToken;
        localStorage.setItem(KEYS.accessToken, state.accessToken);
        localStorage.setItem(KEYS.refreshToken, state.refreshToken);
        setAuthState();
        loadGames();
        setMessage(el.gameMessage, `${data.user?.email} 로그인됨`);
      }

      function logout() {
        state.accessToken = null;
        state.refreshToken = null;
        localStorage.removeItem(KEYS.accessToken);
        localStorage.removeItem(KEYS.refreshToken);
        setAuthState();
        el.gameList.innerHTML = "";
        el.revisionList.innerHTML = "";
        state.selectedGame = null;
        el.selectedLabel.textContent = "게임 선택 필요";
        el.selectedLabel.className = "status warn";
        el.selectedSummary.textContent = "게임을 클릭하면 상세 정보를 표시합니다.";
      }

      async function createGame() {
        if (!state.accessToken) {
          setMessage(el.gameMessage, "로그인 후 이용하세요.", true);
          return;
        }

        const name = el.gameName.value.trim();
        const savePath = el.savePath.value.trim();
        if (!name || !savePath) {
          setMessage(el.gameMessage, "게임명과 저장경로를 모두 입력하세요.", true);
          return;
        }

        const res = await request("/games", {
          method: "POST",
          withAuth: true,
          headers: apiHeaders(true),
          body: JSON.stringify({ name, savePath }),
        });
        const data = await readResponseSafe(res);
        if (!res.ok) {
          setMessage(el.gameMessage, data.error || "게임 등록 실패", true);
          return;
        }

        state.games.push(data.game);
        renderGames();
        setMessage(el.gameMessage, `등록 완료: #${data.game.id}`);
        el.gameName.value = "";
        el.savePath.value = "";
      }

      async function uploadRevision(force = false) {
        if (!state.selectedGame || !state.accessToken) {
          setMessage(el.uploadMessage, "게임 선택/로그인이 필요합니다.", true);
          return;
        }

        const body = {
          checksum: el.checksum.value.trim(),
          sizeBytes: Number(el.sizeBytes.value),
          note: el.note.value.trim(),
        };

        const explicitTs = el.clientUpdatedAt.value.trim();
        if (explicitTs) body.clientUpdatedAt = explicitTs;
        if (force) body.clientUpdatedAt = new Date().toISOString();

        const res = await request(`/games/${state.selectedGame.id}/revisions`, {
          method: "POST",
          withAuth: true,
          headers: apiHeaders(true),
          body: JSON.stringify(body),
        });
        const data = await readResponseSafe(res);

        if (!res.ok) {
          if (res.status === 409) {
            setMessage(
              el.uploadMessage,
              `충돌 감지: 저장타임이 최신보다 과거입니다. 최신: ${data?.latestRevision?.createdAt || "-"}`,
              true
            );
            return;
          }
          setMessage(el.uploadMessage, data.error || "업로드 실패", true);
          return;
        }

        setMessage(el.uploadMessage, `리비전 업로드 완료: #${data.revision.id}`);
        el.checksum.value = "";
        el.sizeBytes.value = "";
        el.clientUpdatedAt.value = "";
        el.note.value = "";
        loadRevisions();
      }

      async function forceRefreshTokens() {
        if (!state.refreshToken) {
          return;
        }

        const res = await request("/auth/refresh", {
          method: "POST",
          headers: apiHeaders(),
          body: JSON.stringify({ refreshToken: state.refreshToken }),
        }, false);
        const data = await readResponseSafe(res);
        if (!res.ok) {
          setMessage(el.uploadMessage, data.error || "토큰 갱신 실패", true);
          logout();
          return;
        }
        state.accessToken = data.accessToken;
        state.refreshToken = data.refreshToken;
        localStorage.setItem(KEYS.accessToken, state.accessToken);
        localStorage.setItem(KEYS.refreshToken, state.refreshToken);
        setAuthState();
      }

      function bootstrap() {
        const savedAccess = localStorage.getItem(KEYS.accessToken);
        const savedRefresh = localStorage.getItem(KEYS.refreshToken);
        if (savedAccess) {
          state.accessToken = savedAccess;
        }
        if (savedRefresh) {
          state.refreshToken = savedRefresh;
        }

        setAuthState();
        loadProviders();
        if (state.accessToken) {
          loadGames();
        }
      }

      el.oauthLoginBtn.onclick = login;
      el.logoutBtn.onclick = logout;
      el.createGameBtn.onclick = createGame;
      el.refreshRevisionsBtn.onclick = loadRevisions;
      el.uploadRevisionBtn.onclick = () => uploadRevision(false);
      el.forceUploadBtn.onclick = () => uploadRevision(true);
      el.refreshBtn.onclick = forceRefreshTokens;

      bootstrap();
    </script>
  </body>
</html>
